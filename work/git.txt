https://blog.csdn.net/LHS__BRU_745/article/details/101475532

完全学会Git的24课堂
1、初始化文档库
cd /d/exergit/
git init

2、配置相关信息
git config -l          ---查看所有配置  --list
git config --system -l
git config  --global -l
git config user.name 'yipeng'
git config user.email 'yipengchen1@163.com'
git config --system user.name 'yipeng'
git config --unset user.name  'yipeng'
git config alias.con 'config -l'   表示config -l 的别名是con
git config --global core.editor notepad   

--global 表示home directory中的.gitconfig配置文件
--system 表示git程序文件夹中的etc\config配置文件
不带参数表示当前工作目录中的配置文件

3、提交文件
git add 1.txt
git status  --- 查看状态
git commit -m '描述、说明信息'  --author='操作者名  <Email邮箱>'
git commit --amend  -m '新的描述'    ---commit指令后修改描述

git add .     ---有个点！  会把新增的文件和被修改的文件加入Git 索引，被删除的文件不会记录在Git中。 
git add -u   把被修改的文件和被删除的文件加入Git索引。
git add -A  把新增的文件、被修改的文件以及被删除的文件全部加入Git索引。

4、图形界面
gitk
gitk all

5、建立分支
git branch  分支名  
git checkout 分支名    --- 切换分支
git checkout -b newbranchname     --创建一个新分支并切换到新分支

合并新分支后并删除新分支
git checkout dev
git merge --no-ff newbranchname
git branch -d newbranchname

强制删除新分支
git checkout dev
git branch -D newbranchname

排除不需要加入的文档库
touch .gitignore
在其中加入
.gitignore
folder


网上学习

安装
安装完后设置用户及邮箱
git config --global user.name 'yipeng'
git config --global user.email 'yipengchen1@163.com'

创建版本库
mkdir learngit
cd learngit
pwd
git init
ls -ah

文件添加到版本库(提交新文件)
git add 1.txt
git commit -m 'shuoming xinxi'

查看状态
git status

查看文件变化
git diff 1.txt   

查看历史记录
git log

图形方式查看历史状态
git log -5 --graph --stat


reset命令：前进或回退历史版本
回退
HEAD表示当前版本，上一个版本HEAD^ 上上一个版本HEAD^^
上4个版本HEAD~4
git reset --hard HEAD^    ---- 回退到上一个版本 
git reset --hard 2ada1e5  ---- 回退到 2ada1e5 这个版本  先用 git reflog 查看操作记录，然后可以选择相关版本

参数： 
--hard       重置本地库、暂存区、工作区
--mixed     重置本地库、暂存区 
--soft        重置本地库

回退后反悔，又回到之前没有回退时
git reset --hard 58abdbe    --(58abdbe 之前的版本号)
git reflog用来记录你的每一次命令，可以找到版本号

git
总结：
HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，
使用命令git reset --hard commit_id。
git reset <commit> 的意思就是 把HEAD移到<commit>
穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。
要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。

Git的版本库里存了很多东西，其中最重要的就是称为（或者叫index）的暂存区
前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：
第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；
第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。

用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别：

git checkout -- file    可以丢弃工作区的修改：
git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令
用命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区
git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。

文件回退总结：
库文件回退：    git reset  --hard 58abdbe    --(58abdbe 之前的版本号)   --- 可先查看需要退回的版本  git reflog filename
暂存区回退：    git reset head filename
工作区回退：    git checkout filename

删除文件
实际删除文件： rm 3.txt
版本库中再做删除操作
git rm 3.txt
git commit -m 'shuoming'

把误删除的找回
git checkout -- 3.txt

如果也从版本库中删除了，需要找回
git reset --hard HEAD^


命令：git checkout C filename
用暂存区中filename文件来覆盖工作区中的filename文件。相当于取消自上次执行git add filename以来（如果执行过）本地的修改。
这个命令很危险，因为对于本地的修改会悄无声息的覆盖，毫不留情。

命令：git checkout branch C filename
维持HEAD的指向不变。将branch所指向的提交中的filename替换暂存区和工作区中相应的文件。
注意会将暂存区和工作区中的filename文件直接覆盖。
命令：git checkout C 或写做 git checkout .
注意：git checkout命令后的参数为一个点（“.”）。这条命令最危险！会取消所有本地的修改（相对于暂存区）。
相当于将暂存区的所有文件直接覆盖本地文件，不给用户任何确认的机会！注意，HEAD指针是由Checkout命令修改指向

$ git checkout branch
#检出branch分支。要完成图中的三个步骤，更新HEAD以指向branch分支，以及用branch  指向的树更新暂存区和工作区。
$ git checkout
#汇总显示工作区、暂存区与HEAD的差异。
$ git checkout HEAD
#同上
$ git checkout -- filename
#用暂存区中filename文件来覆盖工作区中的filename文件。相当于取消自上次执行git add filename以来（如果执行过）的本地修改。
$ git checkout branch -- filename
#维持HEAD的指向不变。用branch所指向的提交中filename替换暂存区和工作区中相   应的文件。
注意会将暂存区和工作区中的filename文件直接覆盖。
$ git checkout -- . 或写作 git checkout .
#注意git checkout 命令后的参数为一个点（“.”）。这条命令最危险！会取消所有本地的  #修改（相对于暂存区）。
相当于用暂存区的所有文件直接覆盖本地文件，不给用户任何确认的机会！
$ git checkout commit_id -- file_name
#如果不加commit_id，那么git checkout -- file_name 表示恢复文件到本地版本库中最新的状态。


Git恢复某个已修改的文件
checkout: 恢复某个已修改的文件(撤销未提交的修改)
git checkout file-name
git checkout commit-id  filename   回退某个文件到指定版本

revert: 还原已提交的修改（已经提交过的修改，可以反悔）
git revert HEAD
git revert commit-id  （还原指定版本）
reset: 撤销当前分支所有修改，恢复到最近一次修改前干净的分支情况
git reset --hard
git clean -fd




reset 命令
在提交层面上，reset将一个分支的末端指向另一个提交。这可以用来移除当前分支的一些提交。比如，下面这两条命令
让 hotfix 分支向后回退了两个提交。
git checkout hotfix
git reset HEAD~2
如果你仔细研究reset命令本身就知道，它本身做的事情就是重置HEAD(当前分支的版本顶端）到另外一个commit。
总的来说，git reset命令是用来将当前branch重置到另外一个commit的，而这个动作可能会将index以及work tree同样影响。

Reset解惑
让我们跟着 reset 看看它都做了什么。它以一种简单可预见的方式直接操纵这三棵树。它做了三个基本操作。
第 1 步:移动 HEAD
reset 做的第一件事是移动 HEAD 的指向。这与改变 HEAD 自身不同(checkout 所做的); reset 移动 HEAD 指向的分支。
这意味着如果 HEAD 设置为 master 分支(例如，你正在 master 分支上)，运行 git reset 9e5e64a将会使master指向9e5e64a。

总的来说，git reset命令是用来将当前branch重置到另外一个commit的，而这个动作可能会将index以及work tree同样影响。
比如如果你的master branch（当前checked out）是下面这个样子:
-A - B - C (HEAD, master)
HEAD和master branch是在一起的，而你希望将master指向到B，而不是C，那么你执行
git reset B以便移动master branch到``B那个commit：
-A - B (HEAD, master)      # - C is still here, but there's no branch pointing to it anymore
注意：git reset和checkout是不一样的。如果你运行git checkout B,那么你讲得到：
-A - B (HEAD) - C (master)
这时HEAD和master branch就不在一个点上了，你进入detached HEAD State. HEAD,work tree,index都指向了B，但是master branch却依然
指向C。如果在这个点上，你执行一个新的commit D，那么你讲得到下面（当然这可能并不是你想要的，你可能想要的是创一个branch做bug fix）:
-A - B - C (master)
         \
          D (HEAD)


限定reset重置范围
前面讲述了 reset 基本形式的行为，不过你还可以给它提供一个作用路径。若指定了一个路径，reset 将会跳 过第 1 步，并且将它的作用范围限定
为指定的文件或文件集合。这样做自然有它的道理，因为 HEAD 只是一个指 针，你无法让它同时指向两个提交中各自的一部分。不过索引和工作
目录 可以部分更新，所以重置会继续进行 第2、3步。现在，假如我们运行git reset file.txt(这其实是git reset --mixed HEAD file.txt的简写形 式，
因为你既没有指定一个提交的 SHA-1 或分支，也没有指定 --soft 或 --hard)，它会:
1，移动 HEAD 分支的指向 (已跳过)
2，让索引看起来像 HEAD (到此处停止)
所以它本质上只是将 file.txt 从 HEAD 复制到索引中。

更进一步，我们可以不让 Git 从 HEAD 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。我们只需运行
类似 于git reset eb43bf file.txt的命令即可。
reset和checkout
checkout这个命令做的不过是将HEAD移到一个新的分支，然后更新工作目录。因为这可能会覆盖本地的修改，Git 强制你提交或者缓存工作目录中
的所有更改，不然在 checkout 的时候这些更改都会丢失。和 git reset 不一样的是，**git checkout 没有移动这些分支。这对于快速查看项目旧版
本来说非常有用。
checkout对工作目录是安全的，它会通过检查来确保不会将已更改的文件吹走。
- checkout不会去修改你在Working Directory里修改过的文件
- checkout则把HEAD移动到另一个分支
- reset会不做检查把working directory里的所有内容都更新掉
- reset把branch移动到HEAD指向的地方

reset和revert
git revert可以用在公共分支上，git reset应该用在私有分支上.
git revert用于记录一些新的提交以反转一些早期提交的影响（通常只是一个错误的提交）。如果你想扔掉工作目录中所有未提交的更改，你应该看到
git-reset，特别是--hard选项。如果你想提取特定文件，就像在另一个提交中那样，你应该看到`git-checkout`，特别是
git checkout <commit> -- <filename>语法。请谨慎使用这些替代方法，因为它们都会丢弃工作目录中的未提交更改。

reset是用来修改提交历史的，想象这种情况，如果你在2天前提交了一个东西，突然发现这次提交是有问题的。
这个时候你有两个选择，要么使用git revert（推荐），要么使用git reset。
上图可以看到**`git reset`是会修改版本历史的**，他会丢弃掉一些版本历史。而`git revert`是根据那个commit逆向生成一个新的commit，版本历史
是不会被破坏的。相比`git reset`，它不会改变现在的提交历史。因此，git revert可以用在公共分支上，git reset应该用在私有分支上。

你也可以把`git revert`当作撤销已经提交的更改，而`git reset HEAD`用来撤销没有提交的更改。就像`git checkout` 一样，`git revert` 也有可能会重写
文件。所以，Git会在你执行revert之前要求你提交或者缓存你工作目录中的更改。如果你的更改还没有共享给别人，`git reset` 是撤销这些更改的简单
方法。当你开发一个功能的时候发现「糟糕，我做了什么？我应该重新来过！」时，reset 就像是 go-to 命令一样。除了在当前分支上操作，你还可以
通过传入这些标记来修改你的缓存区或工作目录：

- --soft C 缓存区和工作目录都不会被改变
- --mixed C 默认选项。缓存区和你指定的提交同步，但工作目录不受影响
- --hard C 缓存区和工作目录都同步到你指定的提交
把这些标记想成定义 `git reset` 操作的作用域就容易理解多了，相比 git reset，它不会改变现在的提交历史。因此，git revert 可以用在公共分支上，
git reset 应该用在私有分支上。



***********************************远程库操作************************
远程库操作
要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；
关联后，使用命令git push -u origin master第一次推送master分支的所有内容；
此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；

用命令git clone克隆一个本地库
git clone git@github.com:kevinyp/ypgit2

创建分支
git checkout -b branch1    
git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：
git branch branch1
git checkout branch1

用git branch命令查看当前分支：

git merge命令用于合并指定分支到当前分支  
把dev分支的工作成果合并到master分支上：
git checkout master
git merge dev

rebase 和merge一样可以合并文件，不过它会消除分支
git checkout dev
git rebase master  --- dev原来的分支节点消失，从master新的节点长出分支，最终只存在一条主线。 

删除dev分支
git branch -d dev

小结
Git鼓励大量使用分支：
查看分支：git branch
创建分支：git branch <name>
切换分支：git checkout <name>
创建+切换分支：git checkout -b <name>
合并某分支到当前分支：git merge <name>
删除分支：git branch -d <name>



git status也可以告诉我们冲突的文件：
Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容
当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。
解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。
用git log --graph命令可以看到分支合并图。
用git log看看分支历史

合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。
如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。
准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward
git merge --no-ff -m 'merge with no-ff' dev

分支策略
在实际开发中，我们应该按照几个基本原则进行分支管理：
首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；
那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；
你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了

Git分支十分强大，在团队开发中应该充分应用。
合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，
而fast forward合并就看不出来曾经做过合并。

Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：
用git stash list命令查看“储藏”的工作现场。
需要恢复一下，有两个办法：
一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；
另一种方式是用git stash pop，恢复的同时把stash内容也删了：

可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：
git stash apply stash@{0}

如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。

查看远程分支
用git remote -v显示更详细的信息 ,  或者  git remote  

推送分支
git push origin master
git push origin dev

使用强制push的方法：
$ git push -u origin master -f 
git强制提交本地分支覆盖远程分支：   git push origin 分支名 --force

我们可以删除已有的GitHub远程库：
git remote rm origin






------远程库的关联、查看、删除 --------------
一.当推送到服务器时首先要添加远程地址的  
git remote add origin https://gitee.com/kingCould/HelloWord.git
二.查看本地添加了哪些远程地址
$ git remote -v
origin https://github.com/zhidao/crm.git (fetch)
origin https://github.com/zhidao/crm.git (push)
sdorigin https://github.com/zhidao/erp.git (fetch)
sdorigin https://github.com/zhidao/erp.git (push)
三.删除本地指定的远程地址
git remote remove origin 删除即可   （只是删除本地链接，并不是删除远程库）


让Git显示颜色，会让命令输出看起来更醒目
git config --global color.ui true

设置别名
$ git config --global alias.st status
$ git config --global alias.co checkout
$ git config --global alias.ci commit
$ git config --global alias.br branch

github上的文件和本地不一致的解决方法：  我的步骤通常是这样
git push    如果失败的话，说明网络上的版本已经更改过了，那就
git pull     如果失败的话，说明网络的版本和本地的版本在合并时可能产生冲突，那就
git stash(把本地的修改全部缓存起来)    然后再   git pull
然后再   git stash pop(把缓存起来的修改恢复)
然后如果有冲突解决冲突，没有就   git push

在github上只能删除仓库,却无法删除文件夹或文件, 所以只能通过命令来解决
首先进入你的master文件夹下, Git Bash Here ,打开命令窗口
$ git --help                                      # 帮助命令
$ git pull origin master                    # 将远程仓库里面的项目拉下来
$ dir                                                # 查看有哪些文件夹
$ git rm -r --cached target              # 删除target文件夹
$ git commit -m '删除了target'        # 提交,添加操作说明
$ git push -u origin master               # 将本次更改更新到github项目上去


windows 下git服务器安装(Gitblit)
0、先需要安装jdk
1、下载Gitblit，下载地址：http://www.gitblit.com/
2、解压缩下载的压缩包即可，无需安装。我的路径为E:\Program Files\gitblit-1.8.0   C:\APP\gitblit-1.8.0
3、转到.\gitblit-1.8.0\data目录，需要修改配置文件    配置gitblit的 defaults.properties
    打开defaults.properties分别搜索替换以下信息(参数说明)：
    server.httpPort = 8888    （http协议的端口 ，请改为自己的端口）
    server.httpsPort = 8443  （https 协议的端口 ，请改为自己的端口）
    server.httpBindInterface = localhost（http协议下服务器端访问的网址 ip，请改为自己的ip）
    server.httpsBindInterface = localhost（https协议下服务器端访问的网址 ip，请改为自己的ip）
    git.repositoriesFolder = ${baseFolder}/git （${baseFolder}/git是其默认目录，也可以替换为自己指定的文件目录）
4、修改installService.cmd找到installService.cmd文件。用“记事本”打开。修改ARCH，32位系统：SET ARCH=x86；64位系 统：SET ARCH=amd64。添加CD为程序目录 SET CD=D:\Git\Gitblit-1.6.0(你的实际目录)。修改StartParams里的启动参数，给空就可以了。
实际要用SET ARCH=x86   设为amd64服务会有问题！！！
5、右键以管理员身份运行installService.cmd 。 
6、在浏览器中打开http://localhost:8888/，成功登陆Gitblit服务器
默认管理员账号密码是admin admin，可以使用默认账号密码登录，然后改密即可。admin/123456  admin/gitadmin

浏览器访问远程库地址：  http://172.168.1.237:8888/repositories/TestGitblit
                                     http://172.168.1.237:8888/repositories/TestGitblit
git clone http://admin@172.168.1.237:8888/r/reborn.git

git remote add origin http://admin@172.168.1.237:8888/r/TestGitblit.git   --建立远程库到本地库的关联
git push -u origin master     --将本地文档推送到远程库

------------配置-----------
@REM arch = x86, amd64, or ia32
SET ARCH=x86
SET CD=C:\APP\gitblit-1.8.0

@REM Be careful not to introduce trailing whitespace after the ^ characters.
@REM Use ; or # to separate values in the --StartParams parameter.
"%CD%\%ARCH%\gitblit.exe"  //IS//gitblit ^
		 --DisplayName="gitblit" ^
		 --Description="a pure Java Git solution" ^
		 --Startup=auto ^
		 --LogPath="%CD%\logs" ^
		 --LogLevel=INFO ^
		 --LogPrefix=gitblit ^
		 --StdOutput=auto ^
		 --StdError=auto ^
		 --StartPath="%CD%" ^
		 --StartClass=org.moxie.MxLauncher ^
		 --StartMethod=main ^
		 --StartParams="" ^
		 --StartMode=jvm ^
		 --StopPath="%CD%" ^
		 --StopClass=org.moxie.MxLauncher ^
		 --StopMethod=main ^
		 --StopParams="--stop;--baseFolder;%CD%\data" ^
		 --StopMode=jvm ^
		 --Classpath="%CD%\gitblit.jar" ^
		 --Jvm=auto ^
		 --JvmMx=1024




-- good git websit
https://www.jianshu.com/p/c8cf9a9b0270
http://git.oschina.net/progit/
https://gitee.com/kevinyp001/events
《Git 学习指南》
Git内容总结
帮助：git commit -h    --查看commit命令的帮助
一：常用操作
A、查询信息类命令
git status
git log --显示提交历史
git log -n 3
git log --oneline   --仅显示一行
git log --stat      --显示统计信息
git log --graph
git log --walk-reflog  mybranch  --显示分支本地历史记录
git reflog   用来记录你的每一次命令，可以找到版本号
git branch -r  --显示远程跟踪分支
git branch -av   ---显示分支详细信息
git remote -v
git show
git diff master origin2/master   --提取前科比较远程库和本地库
git log --oneline master..origin2/master
git tag -l
git config -l --查看配置，可以查看别名
git config --global --list
git diff origin2/master master  --查看版本对比
git diff Head -- filename  --查看工作区和版本库里最新版本的区别


git diff 命令常用格式
git diff               查看尚未暂存的文件更新了哪些部分
git diff filename 查看尚未暂存的某个文件更新了哪些
git diff Ccached                    查看已经暂存起来的文件和上次提交的版本之间的差异
git diff Ccached filename 查看已经暂存起来的某个文件和上次提交的版本之间的差异
git diff ffd98b   b8e7b0 查看某两个版本之间的差异
git diff ffd98b:filename b8e7b0:filename 查看某两个版本的某个文件之间的差异
diff命令最直观的用法其实就是git diff source target。这种source和target都给的情况是最容易理解的，复杂就复杂在如果我们省略一个参数
会怎么样呢？也就是说git diff branch2与git diff branch2 HEAD的结果是一样的，即如果只给一个参数，则这个参数为source，target默认为
当前所在分支的最新的commit。
 
总结一下diff的各种情况：
1. git diff source target返回的结果是target相对于source的变化，这里的source和target可以是commit的hash/分支名/快捷方式。
2. 如果只给一个参数，则这个参数就是source，而默认的target是工作目录，如果工作目录clean的话，则target为当前所在分支的最新commit
3. 如果一个参数都不给，默认的source是暂存目录，而target还是工作目录
4. 如果想要使暂存目录作为target的话，需要使用`--cached`参数

git diff 结果分析
---代表源文件  
+++代表目标文件
通常working area的文件都是被当作目标文件来看待。
- 开头的行，是只出现在源文件中的行
+开头的行，是只出现在目标文件中的行
空格开头的行，是源文件和目标文件中都出现的行
差异按照差异小结进行组织，每个差异小结的第一行都是定位语句，由@@开头，@@结尾。

diff Cgit a/f1 b/f1 //a版本的f1（变动前） 与 b版本的f1（变动后） 比较
index6f8a38c..449b072 100644 //a版本的在index的对象的哈希值 b版本在工作区的对象的哈希值 文件信息（644表示权限）
- a/f1 //变动前的文件
+++ b/f1 //变动后的文件
@@ -1,7 +1,7 @@ //变动前的文件从第一行开始的7行 与 变动后的文件第一行开始的7行存在不同
//以下是比较信息 一行前面有- + ！或者没有表示，分别表示删、增、改、没有修改。



B、提交、提取文件类命令
文件提交到本地库
1、git add 1.txt
     git add .
2、git commit -m "commnet"     -- 好像单引号、双引号都可以
     git commit -m '描述、说明信息'  --author='操作者名  <Email邮箱>'
     git commit --amend  -m '新的描述'    ---commit指令后修改描述
3、为当前版本指定标签
     git tag release3.1 master -m 'relase version'

文件提交到远程库
1、git push -u  origin(远程库) master(本地库)    -- 把本地库的master分支同步到远程仓库。加上了 Cu参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。
git push origin(远程库) master(本地库)
git push release3.1

push 命令只适合把文件传到不带工作区的共享版本库中(裸版本库)，建立裸版本库的方法是clone时
用--bare选项,例如：
git clone --bare /fist-steps  /first-steps-bare
上传操作：git push /first-steps-bare master
 
2、提取文件到本地工作区
git fetch /first-steps-bare   --fetch:获取提交,会将其他库所有分支中尚未存在于本地库中的提交获取到。
fetch是单向操作，提交只能从远程库传送到本地库，如果将本地库提交到远程库要用push命令。
提取前可比较远程库和本地库
git diff master origin2/master
利用本地分支操作别处版本库：通过获取(fetch)操作来创建一个本地分支orig2tolocal。
git fetch origin2 master:orig2tolocal
获取最新文件到工作区/本地  pull = fetch + merge
git pull  --会从默认版本库中提取回文件，也可用下述/first-steps-bare(源库名)指定任意版本库的路径。
git pull /first-steps-bare master 
git pull --rebase   --会将从远程库获取的版本合并到本地后并消除钻石链
git pull origin2 master(源):orig2tolocal(目标) 

push、与pull fetch的区别
push 通常不会带来合并，且只对有相同分支名的才提交文件，只在快进模式下被允许，pull、fetch所选取的是所有分支，且会合并。


C、恢复到指定版本命令
git中，恢复文件到某一版本通常称为检出(checkout)操作。
1、git checkout  1.txt
2、git checkout releas3.1  获取通过标记提交的版本releas3.1 
3、git checkout -m 版本号 文件/文件夹

文件恢复(回退)总结：
reset 重置暂存区
git reset Head .  --重置暂存区为当前head版本  第二个参数为当前的目录或文件
库文件回退：git reset  --hard 58abdbe    --(58abdbe 之前的版本号)   --- 可先查看需要退回的版本  git reflog filename
git reset --hard HEAD  --hard参数确保暂存区和工作区所发生的全部修改都会被丢弃。Head表示当前分支必须
是最后一个已关闭的提交。
暂存区回退：    git reset head filename
工作区回退：    git checkout filename


D、分支类操作
git branch                --查看分支
git branch a-branch       --创建分支 为当前提交创建分支
git checkout a-branch     --切换分支
git checkout -b b-branch  --创建并切换分支
git branch -d c-branch    --删除分支
git merge b-branch        -- 合并branch_name 到当前分支  快进合并
git merge --no-ff b-branch
git merge b-branch --no-ff --no-commit  --防止快进操作，防止可能失败的测试而停止任何提交。
git checkout --force b-branch
git reset --hard 39ea21a   --重置分支指针到39ea21a 
git push origin1 :b-branch   --删除远程库origin1中的分支b-branch！！！
git branch 不带参数：列出本地已经存在的分支，并且在当前分支的前面加“*”号标记，例如： 
git branch -r 列出远程分支，例如： 
git branch -a 列出本地分支和远程分支。 
git branch branchname  创建分支 
git checkout branchname 切换分支

Git里面，git checkout命令用于切换分支或恢复工作树文件。git checkout是git最常用的命令之一，
同时也是一个很危险的命令，因为这条命令会重写工作区。
创建一个hotfix分支
git checkout -b|-B <new_branch> [<start point>] 
git checkout -b hotfix-1.2.1 master

git checkout 26a2e80 # 26a2e80 是一个commit号，这个命令会把index区域和工作区域的内容都更新
git checkout -- README # README是想恢复的文件名，恢复成index区域里面的内容，为什么要加“--”呢，这个是为了告诉Git，
这是一个文件而不是一个分支
Git checkout . # 从index区域恢复所有文件



二：高级操作
1、变基础操作
假设目前在分支 a-branch 上
git merge master    --- 将指定的master分支的内容合并到当前的a-branch分支上！！！
git rebase master   --变基操作，指定要将活动分支上的最新修改纳入哪一个分支(这里将最新修改纳入到master分支)
如果有冲突，解决冲突后继续执行（编辑冲突文件后，git add filename ，然后git rebase --continue）
git rebase --continue  --也可执行abort skip等选项  
git mergetool

2、移植操作
假设目前在分支 feature-a 上
git rebase master --onto release1   --将原分支master上分岔出的新分支(feature-a)的提交移植到另一个分支release1上
这里，rebase命令的第一个参数所指定的是原分支(即这里的master分支)。然后，git会去确认活动分支(feature-a)上所有不属于原分支的所有
提，然后通过 --onto选项将这些提交拷贝到指定位置上(即这里的release1)。
详细步骤：
a: 切换到待移动的分支上
    git checkout feature-a
b: 确定原位置
    git会将所有不属于原分支中的提交移出来。
c: 检查所要移动的内容
    git log master..feature-a  (显示的是在feature-a上而不在master上的提交)
d: 执行变基操作
    git rebase master --onto release1   (git rebase origin  --onto target )


3、命令别名
git config --global alias.st status
git config --global alias.ci commit
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.pl  pull --rebase
git config --global alias.lg "log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %C(bold blue)%s%Creset %Cgreen(%cr) <%an>%Creset' --abbrev-commit --date=relative"
git config --global alias.lga "log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %C(bold blue)%s%Creset %Cgreen(%cr) <%an>%Creset' --abbrev-commit --date=relative --author xujun"
git config --global alias.last "log -1"

git config 文件的存放位置主要有三个位置
1）./etc/gitconfig 文件：包含了适用于系统所有用户和所有库的值。如果你传递参数选项’Csystem’ 给 git config，它将明确的读和写这个文件。
git config --system user.name "xujun"  
git config --system user.email “gdutxiaoxu@163.com"
2）~/.gitconfig 文件 ：具体到你的用户。你可以通过传递 Cglobal 选项使 Git 读或写这个特定的文件。
git config --global user.name "xujun"  
git config --global user.email “gdutxiaoxu@163.com"
3) 位于 git 目录的 config 文件 (也就是 .git/config) ：无论你当前在用的库是什么，特定指向该单一的库。每个级别重写前一个级别的值。因此，在.git/config中的值覆盖了在/etc/gitconfig中的同一个值。

删除远端服务器上文件，保留本地文件
git rm -r --cached some-directory
git commit -m 'Remove the now ignored directory "some-directory"'
git push origin master

Git pull 拉取远程内容强制覆盖本地文件
git fetch --all
git reset --hard origin/master
git pull
git pull origin master:dev   --- 将远程库上master分支的内容拉到本地dev分支中，如果拒绝可强制下拉 git pull -f origin master:dev
git push origin :dev   --删除远程版本库中的dev分支




冲突解读
<<<<<<<(七个小于号)和=======(七个等号) 之间的内容是当前分支所更改的内容
>>>>>>>(七个大于号)和=======(七个等号) 之间的内容是外部分支的内容。

分支命令
1. git branch                         --- 显示本地分支列表
2. git branch   <branchname >                       --- 基于当前头指针创建分支
3. git branch   <branchname >  <start-pint>  --- 基于当提交指针创建分支
4. git branch   -d  <branchname >                 --- 删除分支，没合并到其它分支时拒绝删除
5. git branch   -D  <branchname >                 --- 强制删除分支 
6. git branch   -m  <oldbranch>  <newbranch>  --- 重命名分支
7. git branch   -M  <oldbranch>  <newbranch>  --- 重命名分支
8. git push origin :br  (origin 后面有空格)   ----git 删除远程分支
9. git remote prune orig    ----- 删除掉不存在的远程库分支信息
10. git checkout branchname      ---切换分支
11. git checkout -b  <branchname>  <start-pint>      ---创建并切换分支   
12. 合并分支到主线
git checkout master
git merge branch1     ---将分支branch1 合并到master

删除掉不存在的远程库分支信息
git remote prune orig

在本地建立远程库上的分支
git pull orig dev:dev
git show-ref   --查看全部本地引用

或显式的从远程分支建立本地分支
git checkout -b dev orig/dev    --- 从远程orig/dev 分支建立本地dev分支
git remote rename  orig  orignew
git remote rm orig

在远程库上建立分支
git push orig  new_branch    --即通过将本地分支推送到远程库的方式在远程库建立分支

git branch --set-upstream-to=origin/remote_branch  your_branch
其中，origin/remote_branch是你本地分支对应的远程分支；your_branch是你当前的本地分支。


理解gitfetch,关键是理解FETCH_HEAD，FETCH_HEAD指的是：某个branch在服务器上的最新状态。
一般来说，存在2种情况：
如果没有显示地指定远程分支，则远程分支的master将作为默认的FETCH_HEAD。
如：git fetch origin 或者 git fetch origin master
如果指定了远程分支，则将这个远程分支作为FETCG_HEAD。
如：git fetch origin dev 设定当前分支的FETCG_HEAD为远程服务器的dev分支。
它就相当于git pull origin dev的第一步，并不会在本地创建新的分支。另外git fetch origin dev这个命令可以用来测试远程分支dev是否存在。

git fetch origin dev :branch1          （git fetch  远程库别名  远程库分支名:本地库分支名    如果本地分支不存在则创建，否则更新本地分支）
pull 命令也类似  git pull  origin dev(远程版本库分支) :branch1(本地分支)  
1.首先执行上面的fetch操作
2.使用远程dev分支在本地创建branch1分支（但不会切换到该分支）
3.如果本地不存在branch1分支，则会自动创建一个新的branch1分支，如果存在branch1分支，并且是fast forward，
则会自动合并这2个分支，否则会阻止以上的操作。
 
git reflog show master  --- 查看日志   可挽救错误的重置

分支分为:
      本地分支、远程跟踪分支(远程版本库短名称/远程版本库分支   构成)


git add 的几种参数区别： 
git add -A 保存所有的修改 
git add . 保存新的添加和修改，但是不包括删除 
git add -u 保存修改和删除，但是不包括新建文件。 


reset命令  (重置命令     改变本分支游标，即改变头指针的引用文件)
重置命令一个用途就是修改引用(如master)的游标指向。重置一般是针对暂存区(index区)，有两种用法：
git reset <commit>  -- paths       --- 用指定提交commit 下的文件paths 替换暂存区文件，相当于取消之前的  git add <paths>
git reset --hard  <commit>   ---有不同的选项，可对暂存区或工作区进行重置。[--soft | --mixed | --hard | --merge | --keep]
 --hard 更改head的引用，替换暂存区，替换工作区。
 --soft  只更改head的引用指向，不替换暂存区和工作区。
 --mixed  默认值，更改head的引用和暂存区。

checkout命令   (检出命令   改变分支，即改变头指针)
检出命令，会修改工作区，有三种用法：
git chekcout  <commit> -- pahts    ----用于指定版本的文件覆盖工作区中的对应文件，省略commit，则用暂存区文件进行覆盖工作区文件。
git chekcout  <branch>             ---- 主要用于切换分支，当不是branch而是一个文件引用时，会进入到“头指针分离状态”。
git chekcout -b <newbranch> <start_pint>  ----用于创建和切换分支。

rebase 命令
它的作用简要概括为：可以对某一段线性提交历史进行编辑、删除、复制、粘贴；
1.合并多个commit为一个完整commit。如把 A B C D 提交合并为 A  B'
 git rebase -i  [startpoint]  [endpoint]       其中-i的意思是--interactive，即弹出交互式的界面让用户编辑完成合并操作，[startpoint] [endpoint]
                                                               则指定了一个编辑区间，如果不指定[endpoint]，则该区间的终点默认是当前分支HEAD所指向
                                                               的commit(注：该区间指定的是一个前开后闭的区间)。
git rebase -i B    ---然后进行编辑 修改弹出文件的内容即可。

2.将某一段commit粘贴到另一个分支上。如有两个分支  A B C D E F(dev)，A G(master),希望  master合并部分dev分支内容。A G C' D' E'
希望将develop分支中的C~E部分复制到master分支中，这时我们就可以通过rebase命令来实现（如果只是复制某一两个提交到其他分支，建议
使用更简单的命令:git cherry-pick）。 
git rebase   --onto  [branchName]   [startpoint]   [endpoint]  
git  rebase   C^   D   --onto master    
-----注:因为[startpoint] [endpoint]指定的是一个前开后闭的区间，为了让这个区间包含C提交，我们将区间起始点向后退了一步。 rebase是一个开闭集！
当前HEAD处于游离状态，虽然此时HEAD所指向的内容正是我们所需要的，但是master分支是没有任何变化的，git只是将C~D部分
的提交内容复制一份粘贴到了master所指向的提交后面，我们需要做的就是将master所指向的提交id设置为当前HEAD所指向的提交id就可以了，即:
git checkout master
git reset --hard  8c3110f          ------ 8c3110f     指针游离态的文件编号

日常提交代码的过程中，我想我用到频率最高的命令之一就是git pull --rebase, 很多人都知道，默认情况下，git pull就相当于执行了如下命令：
git fetch
git merge FETCH_HEAD
而git pull --rebase:
git fetch
git rebase FETCH_HEAD

rebase   通常我使用rebase最多的方式基本就是这样：
git rebase [<upsteram>] [<branch>]

命令：
git rebase [-i | --interactive] [<options>] [--exec <cmd>] [--onto <newbase>] [<upstream> [<branch>]] 
git rebase [-i | --interactive] [<options>] [--exec <cmd>] [--onto <newbase>] --root [<branch>] 
git rebase --continue | --skip | --abort | --quit | --edit-todo | --show-current-patch

git rebase命令主要参数解析：
--onto<newbase>:    newbase指的是需要rebase代码的起点，newbase可以是分支（branch），也可以是任意的提交
                                  记录(commit1)。rebase成功后，将以newbase为代码分支起点。
<upstream>:  需要与newbase比对的分支或提交记录。
<branch>： 需要rebase的工作分支。默认为HEAD，例如dev1
--continue  当处理完冲突后，可以使用该命令让rebase继续。
--abort  终止rebase操作，将HEAD设置为rebase之前的分支。如果指定了<branch>，则HEAD将重置为<branch>。
             否则，HEAD将被重置为rebase之前的分支。
--quit   终止rebase操作，但不会将HEAD重置为原来的分支。index和working tree将不会发生任何改变。
--autostash   在rebase操作之前自动stash当前分支未提交的代码，在rebase操作结束后，自动将stash的记录进行unstash，
                    并与rebase后的代码合并。注意，此操作有可能会导致严重的冲突（conflict），谨慎使用。
-m
--merge   进行rebase操作的时候，同时使用merge进行代码合并。需要注意的是，在进行rebase merge产生冲突的时候，ours
                为<upstream>指定的分支，theirs为<branch>指定的分支。原因是，rebase merge work的工作原理为，将<branch>
                上的所有提交记录在<upstream> 分支上进行重提交。

git rebase用于把一个分支的修改合并到当前分支。 
假设你现在基于远程分支”origin”，创建一个叫”mywork”的分支  ： $ git checkout -b mywork origin 
假设远程分支”origin”已经有了2个提交：C1  C2
我们本地做了两次提交 C5  C6，远程分支有人做了两次提交C3 C4，这样远程：C1 C2 C3 C4  本地：C1 C2 C5 C6
可以用pull命令把orign分支上的修改拉下来并且和本地的修改合并；也可让mywork分支历史看起来像没有经过任何合并一样，用git rebase:
git checkout mywork
git rebase origin       
这些命令会把你的”mywork”分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git/rebase”目录中),
然后把”mywork”分支更新 为最新的”origin”分支，最后把保存的这些补丁应用到”mywork”分支上。 最后形成 C1 C2 C3 C4  C5 C6

实质上:
merge是对目前分叉的两条分支的合并
rebase是对当前分支记录基于任何commit节点(不限于当前分支上的节点)的变更.
rebase的base不能理解为分叉的基点,而是整个git库中存在的所有commit节点:
在git pull ―-rebase的时候,这个当前分支是本地分支,commit节点是远程分支的head
在git rebase master的时候,这个当前分支是feature分支,commit节点是master分支的head
在git rebase -i的时候,这个当前分支就是当前工作分支,commit节点是在 -i后注明的commit

git rebase master
在把分支合并回master的时候,用git rebase master代替git merge master.(注意,只在合并之前使用,否则多人协作会遇到冲突)
这样的好处有两个:
log里不会出现一个Merge branch 'master' into hotfix/xxx的节点
master分支上在这次merge之前已经被提交的上一次工作和这一次工作的顺序更清晰,因为rebase会让这次feature的分叉节点改到上一次工作后.对于master分支来说,我们并不关心checkout新的feature的顺序,我们更关心merge新的feature的顺序.
我都建议你对不太重要的分支合并采用rebase,对重要的分支合并采用merge.这样会让主干的更改更清晰,而分支不会扩散地太远. 

git pull ―-rebase
多人在同一分支上工作的时候(包含master分支和多人合作的feature等分支),在git pull的时候会遇到冲突,git pull的默认行为是git fetch&git merge,merge的对象是远程分支和本地分支.  它的好处基本上与上一条无异,还多了一条:
使用merge行为的pull会将其他人的工作作为外来的分叉,从而在graph上产生一个新的分叉, 并且其他人这一段时间所做的所有的工作都会在graph上被抬升出去,如果这段时间其他人做的工作很多,graph的主线会变得丧失了主线的意义(因为它太单薄了,很多工作根本没反应上来).

git rebase -i
使用这条命令可以修改分支的记录,比如觉得之前的commit修改内容不够单元化,像是修改了文案1为文案2,修改了文案2为文案3,这种记录对于master分支来说是没必要关注的信息,最好通过git commit --amend或者rebase的方式修改掉.
不过并不推荐在提交之前手动做一次整个分支的squash,如果是rebase方式合并的话,也许更有意义,为了不影响别人,只用它修改未push的commit,或者如果一条分支只有一个人,你也可以修改已经push的commit.

git merge    git rebase   git cherry-pick
https://juejin.cn/post/7034793065340796942
一、git merge(用“兼并” 记忆方便)
1.使用
将分支切换到 master 上去：git checkout master
将分支 feature 合并到当前分支（即 master 分支）上：git merge feature
2.特点
只处理一次冲突
引入了一次合并的历史记录，合并后的所有 commit 会按照提交时间从旧到新排列
所有的过程信息更多，可能会提高之后查找问题的难度

二、git rebase
1.使用
与 git merge 一致，git rebase 的目的也是将一个分支的更改并入到另外一个分支中去。
执行 git rebase master 的操作，意味着让当前分支 feature 相对于 分支 master 进行变基
遇到冲突，进行对比的双方分别是 master 分支的最新内容和 feature 分支的第一次提交的内容。
在我们解决了冲突之后，需要执行 git rebase --continue 来继续变基的操作。
执行之后又遇到了冲突，这次是与 feature 分支的第二次提交进行对比出现的冲突，意味着我们需要多次解决同一个地方的冲突。
//将分支切换到master分支
git checkout master
//把test分支合并到master分支
git rebase test
这个和上述不同，是 将master 变基为test，即master 以 test为基础。 上述 git rebase master是以master为基础。
2.特点
改变当前分支从 master 上拉出分支的位置
没有多余的合并历史的记录，且合并后的 commit 顺序不一定按照 commit 的提交时间排列
可能会多次解决同一个地方的冲突（有 squash 来解决）
更清爽一些，master 分支上每个 commit 点都是相对独立完整的功能单元
3.交互模式
git rebase -i HEAD~4
指定了对当前分支的最近四次提交进行操作。
4.git rebase和git merge的区别
rebase 会把你当前分支的 commit 放到公共分支的最后面,所以叫变基。就好像你从公共分支又重新拉出来这个分支一样。
而 merge 会把公共分支和你当前的 commit 合并在一起，形成一个新的 commit 提交
优劣：
git merge 优点是分支代码合并后不破坏原分支代码的提交记录，缺点是会产生额外的提交记录并进行两条分支的合并
git rebase 优点是可以将对象分支的提交记录续道目标分支上，形成线性提交历史记录，review时更加直观
5.什么时候使用rebase
不能在一个共享的分支上进行git rebase操作
因为往后放的这些 commit 都是新的,这样其他从这个公共分支拉出去的人，都需要再重新merge，导致提交记录混乱
总结
合代码到公共分支上时用git merge
合代码到个人分支时用git rebase，形成线性提交历史记录

三、git cherry-pick
1.基本使用
git cherry-pick 的使用场景就是将一个分支中的部分的提交合并到其他分支
git checkout master 
git cherry-pick <commitHash> 
使用以上命令以后，这个提交将会处在master的最前面
2.合并多个提交
git cherry-pick <hashA> <hashB>     // 合并两个提交
git cherry-pick <hashA>..<hashB>    // 合并从A到B两个提交中到所有提交，但不包含A
git cherry-pick <hashA>^..<hashB>   // 合并从A到B两个提交中到所有提交，包含A
3.pick以后产生了冲突
当执行了cherry-pick 命令如果有冲突，就会报冲突错误 
git cherry-pick --continue  // 1. 解决完冲突以后，继续下一个 cherry-pick
git cherry-pick --abort   // 2. 如果不想解决冲突，要放弃合并，用此命令回到操作以前
git cherry-pick --quit   // 3. 不想解决冲突，放弃合并，且保持现有情况，不回到操作以前
4.转移到另一个代码库
git remote add target git://gitUrl //添加一个远程仓库target
git fetch target                   //远程代码抓取到本地
git log target/master              //获取该提交的哈希值
5.应用场景
想要合并某些内容，但又不想包含整个分支。这时用cherry-pick来合并单次提交


-------- Git 总结2 ------------
重要的命令： diff、reset、checkout、reflog、branch、merge、fetch、pull、push、cherry-pick、rebase、、、、、

git diff 命令的三种比较
1、git diff                        ----- 比较暂存区和工作区的文件内容     显示信息，暂存区在前，工作区在后
2、git diff --cached         ----- 比较head和暂存区的文件内容
3、git diff head               ----- 比较head和工作区的文件内容


git reset  重置命令    -----可将工作区、暂存区、版本库回退到任一提交。一般情况下主要用于重置暂存区。 该命令一个用途是修改引用的游标指向。
用法一：git reset [-q] [<commit>] [--] <paths>...         ----- 用指定提交替换暂存区中的文件，不会重置引用，更不会改变工作区。
用法二：git reset [--soft | --mixed | --hard | --merge | ---keep ] [-q] [<commit>]   ---会重置引用，且根据不同选项可以对暂存区和工作区进行重置。

git reset --soft   <commit>    ---- 即只更改引用的指向，不改变暂存区和工作区。
git reset --mixed  <commit>    ---- 默认选项，可省略mixed，可更改引用的指向以及重置暂存区。git reset   ---- 仅用head指向的目录树重置暂存区
git reset --hard <commit>    ---改变引用、暂存区和工作区。

git reflog  可以用于挽救上述错误的重置，它的日志显示顺序是最新的在最上面！直接查看日志 最新的提交在最下面！！！
git reset --hard head^   重置到前一个版本
git reflog show master | head -5
git reset --hard master@{2}  重置到重置前的版本---挽救错误的重置


git  checkout 命令    修改head本身的指向！ 上述reset主要用途之一是修改引用(引用分支)的游标指向，即修改游标内容的指向。checkout是修改游标。
1、用法一：git checkout [-q]  [<commit>] [--] <paths>...    
2、用法二：git checkout [<branch>]
3、用法三：git checkout [-m ] [[ -b | --orphan] <new_branch> ] [<start_point> ]
1、中commit是可选的，省略相当于从暂存区进行检出。用指定的文件覆盖工作区中对应的文件。
2、会改变head头指针，主要用作切换到分支。
3、主要用作创建和切换到新的分支，新的分支从start_point指定的提交点开始创建。
git checkout                      -----汇总显示工作区、暂存区与head的差异。
git checkout HEAD            -----同上，注意,HEAD 是大写！！！
git checkout -- filename    -----维持HEAD的指向不变。用branch所指向的提交中的filename替换暂存区和工作区中相应的文件。
git checkout --  .                -----很危险，会取消所有本地工作区修改，相当于用暂存区的所有文件覆盖本地工作区文件。


git cherry-pick   拣选指令：从众多的提交中拣选出一个提交应用在当前的工作分支中。该命令需要一个提交id。
git cherry-pick 23d9422     ----将分支2上的某一次提交23d9422  合并到当前分支上。
git cherry-pick C3 C4 C7    ----将三个不同分支上的提交C3、C4、C7 h合并到当前分支上。
git cherry-pick  -n  C3 C4 C7
-n  参数    ------如果不想git cherry-pick自动进行提交，则加参数-n即可。
-e  参数     ------如果想要在cherr-pick后重新编辑提交信息，则使用git cherry-pick -e命令
git cherry-pick    Ccontinue, Cabort，Cquit

gti cherry-pick 命令：常见两个用途
1、git cherry-pick 命令通常用于把版本库中一个分支的特定提交引入到一个不同分支中(当前分支)。常见用法是把开发分支
的提交移植到维护的分支中。
git checkout rel_2.3       ----- rel_2.3 ： 维护分支  dev：维护分支   dev~2： 维护分支的前2个版本
git cherryp-pick dev~1

2、cherry-pick 另一常见用途是重建一些列提交，通过从一个分支选一批提交，然后把它们引入到一个新分支。
假设在my-dev分支上有一些列提交，想把它引入到master分支，但是以不同的顺序引入：
假设 master分支  A B C D
假设 my_dev分支 A B V W X Y Z
git checkout master
git cherry-pick my_dev^      # Y
git cherry-pick my_dev~3    # W
git cherry-pick my_dev~2    # X
git cherry-pick my_dev        # Z
最后得到： master :   A B C D y w x z
也可选择一个提交范围
git cherry-pick my_dev..my_dev~3

git revert ：命令
和cherry-pick 命令大致相同，但它用于给定提交的逆过程，常见用途是“撤销”提交。
假设 master分支  A B C D E F G
git revert  master~3    # commit D 


安装和初始化
git config --global user.name “zhagnsan”
git config --unsert user.name “zhagnsan”
git config --global  user.email  “zhangsan@163.com”
git config -l
cd /path/mydir
git init     or       git init Cbare
git clone http://admin@172.168.1.237:8888/r/reborn.git
---建立远程库到本地库的关联
git remote add origin http://admin@172.168.1.237:8888/r/TestGitblit.git   


查看信息
git log
git log Cp     ---显示版本间的内容差异
git log -5  
git log Csince=“6 hours”   或者  --before=“2 days”
git log -1 head~3    或者 git log -1 head^^^ 
git log <start point> …<end point>
git log -n 3
git log --oneline
git log --stat
git log --shortstat  --oneline
git log --dristat
git log --graph
git blame <some file>
git diff   ----比较暂存区和工作区的文件内容显示信息，暂存区在前，工作区在后
git diff commitid     ----比较工作区和版本库之间的区别


分支操作
git branch                         --- 显示本地分支列表
git branch   <branchname >                       --- 基于当前头指针创建分支
git branch   -D  <branchname >                 --- 强制删除分支
git checkout master
git checkout -b  <branchname>  <start-pint>      ---创建并切换分支
git checkout -b dev origin/dev    --- 从远程orig/dev 分支建立本地dev分支
git branch   -M  <oldbranch>  <newbranch>  --- 重命名分支
git merge branch1     ---将分支branch1 合并到master
git remote prune origin   -----删除掉不存在的远程库分支信息
git pull origin dev:dev    -----在本地建立远程库上的分支
git show-ref   ---查看全部本地引用


远程版本库操作
git branch -r     --- 显示远程分支列表
git clone http://admin@172.168.1.237:8888/r/reborn.git
git clone --depth 200 <some repository>
git remote add origin http://admin@172.168.1.237:8888/r/reborn.git   ----取别名
git branch <newbranchname> <remote branch>  ----基于远程分支创建本地分支
git fetch    ---- 从别名为origin的远程版本库中获取修改，但不合并到本地分支
git fetch <remote repository>
git pull
git pull <remote repository>  ----从远程版本库中获取修改，并合并到本地分支
git push   ---- 把修改推送到别名为origin的远程版本库同名分支
git push <remote repository>  <local branch>   ---- 把修改推送到远程同名分支
git push <remote repository>  <local branch>:<remote branch>
---- 把修改从本地分支推送到远程版本库的分支
git push <remote repository>   :<remote branch>   ----删除远程版本库中的分支
git remote -v   -----查看远程库信息 
git remote prune  <remote repository>     ----- 删除掉不存在的远程库分支信息
git remote rm <remote repository>   ---- 在本地库中删除远程库简称及远程库分支
git remote show [remote-name] 查看某个远程仓库的详细信息
git remote show origin

使用git在本地新建一个分支后，需要做远程分支关联。如果没有关联，git会在下面的操作中提示你显示的添加关联。
关联目的是在执行git pull, git push操作时就不需要指定对应的远程分支，你只要没有显示指定，git pull的时候，就会提示你。
git branch --set-upstream-to=origin/remote_branch  your_branch
其中，origin/remote_branch是你本地分支对应的远程分支；your_branch是你当前的本地分支。 



执行git reset --hard head后工作区的文件丢失找回
find .git/objects -type f | xargs ls -lt | sed 30q    ----- 最近30次的文件
git cat-file -p ID > filename.txt                          ----- 是下述例子中74去掉/后和后面的字符串组合成的字符串

$ find .git/objects -type f | xargs ls -lt | sed 5q
-r--r--r-- 1 shenyipeng 1049089  47019 Feb 19 09:03 .git/objects/74/52305b3c75c253891cec4b8df9f6f963392c6f
git cat-file -p  7452305b3c75c253891cec4b8df9f6f963392c6f > jc.txt


git stash             ----保存目前工作区内容
git stash list       ----显示保存工作的列表
git stash pop     ----弹出目前保存的内容
git stash apply stash@{1}
git stash clear    -----删除进度列表



《Git版本控制管理》
更改提交的相关命令
checkout：切换到不同分支，当前分支和HEAD引用会变为匹配给定分支的头。
reset：此命令不会改变分支，如果提供一个分支名，它会改变当前工作目录的状态，使其看起来像给定分支的头，换言之，
          它会重置当前分支的HEAD引用。但不会改变当前分支。
revert：命令用于全部提交，而不是文件。

变基提交
git rebase 命令：用来改变一串提交以什么为基础。此命令至少需要  提交将迁往的分支名。默认情况下，不在目标分支中的
当前分支的提交会变基。下述中，目标分支是master。 即：变基当前分支的提交到目标分支，目标分支是紧挨rebase后的分支。
假设 master分支  A B C D E
假设 topic分支     A B W X Y Z
git checkout topic
git rebase master  
或者
git reabse master topic
会变为：A B C D E w x y z
git rebase命令也可以用--onto选项吧一条分支上的开发线整个移植到完全不同的分支上。
git rebase --onto master maint^  feature

快进与非快进
远程库   .... A   B ,克隆到本地后进行了 C  D提交，push时如果远程库没有其它提交，
则合并为 .... A  B   C   D 这种称为快进操作。
快进：本质上是一个简单的线性历史记录推进操作。
非快进操作：Origin的历史记录不会简单地从B快进。
如果别人已经在远程库进行了 X Y 提交，
则不能简单的进行直接提交。要么覆盖别人的提交 X Y,这时可以用git push -f 提交进行覆盖。
一般情况下，应该合并这两个交替的历史记录，但两个历史记录都必须存在于一个版本库
中的两个不同分支上，所以应该首先进行fetch操作到本地远程追踪分支，从而在本地形成两个不同
的分支再合并。
git fetch            ---- 将远程分支的 X Y提交获取到本地形成 origin/master 分支
git merge origin/master     ---- 将追踪远程分支合并到本地 master分支
然后再将合并后的推送到远程库：
git push

refspec语法 
本身始终是 “源：目标”
[+]source:destination
refspec 关系总结
                    源                         目 标
push    推送的本地引用     更新的远程引用
fetch   抓取的远程引用      更新的本地引用




《精通Git  第二版》Scott Chacon 、BendStraub
git status 查看文件变更状态
git diff 可以更详细的查看哪些文件有什么改变。git diff 的输出相当于是补丁。

从远程仓库获取数据
git fetch [remote-name]  会拉取并不会合并远程库数据到本地仓库。
git clone 命令会自动设置本地master分支，使其跟踪被克隆的服务器端的master分支。
git pull 会从被克隆服务器上获取更新数据并自动合并到当前工作目录下的本地数据。
git push [remote-name] [branch-name]

检查远程仓库
git remote 
git remote -v
git remote show [remote-name]    ---查看远程库的更多信息

删除和重命名远程仓库
git remote rename old_branchnm  new_branchnm
git remote rm old_branchnm

分支合并
把other_branch 合并到 branch中，应该检出目标分支并把其它分支合并进去。
git checkout branch
git merge other_branch       ----  other_branch  ：被合并的分支 

查看已并入当前分支的所有分支和未并入的所有分支
git branch --merged   和  git branch --no-merged

远程分支 是  指向远程仓库的分支的指针，这些指针存在于本地且无法被移动。远程
分支有点像书签。表示形式是(remote)/(branch)。git clone时会自动建立远程分支
指针origin/master，也会创建本地master分支，一开始这两个指针指向一样的位置。
git fetch origin   ---将会从服务器取得所有本地尚未包含的数据，然后把远程分支
指针origin/master移动到最新的位置上去。

git  fetch origin  --- 如果远程服务器上有serverfix 分支本地没有，则上述命令将会
基于远程服务器分支在本地创建远程分支指针 origin/serverfix，但不会创建本地分
支serverfix，要把上述远程分支上的工作合并到当前工作分支，执行：
git merge origin/serverfix   ---- 假设工作在master分支，则会将远程分支合并到master上。
如果要创建自己的本地serverfix分支，可执行：
git checkout -b serverfix  origin/serverfix 

跟踪分支
基于远程分支创建的本地分支会自动成为跟踪分支(tracking branch)，有时候也叫上游
分支(upstream branch)。跟踪分支是与远程分支直接关联的本地分支。有跟踪分支，执行
git push 或git pull 命令时，git会知道要将数据推送到哪个远程服务器的哪个分支。自己
创建跟踪分支:
git checkout -b [branch] [remotename]/[branch] 或者
git checkout --track  origin/serverfix     ---- 会自动创建serverfix跟踪分支
给本地已存在的分支设置跟踪分支可以用 -u 或  --set-upstream-to 选项设置任意远程分支。
git branch -u origin/serverfix  
显示跟踪分支： git branch -vv

删除远程服务器上的分支
git push origin --delete serverfix  

主要章节 2、3、5、7、8、9、10
第2章
git操作：修改->暂存区(缓存区)->提交已暂存的变更
git diff --staged(--cached)
git commit
git commit -m 'remark info'
git commit -a -m 'remark info'     ----跳过-a 参数 add，直接提交

git rm filename          ---从暂存区中移除文件
git rm -f filename       ---强制移除，从暂存区和工作目录移除文件
git log -p - 3   ----显示最近3次的提交记录的详细信息。 -p详细log



------------ 《精通Git》---------
版本比较
1、git diff：比较的是当前工作目录和暂存区的的差异。
2、git diff --staged(--cached)：比较的是暂存区和上一次提交的差异。

git reset HEAD  aa.txt
撤销已暂存的文件。

git checkout -- aa.txt
撤销对工作区的修改。
git checkout -- [file]是一条危险命令，执行该命令后，任何对[file]文件做出的修改都会丢失，此命令将会用之前的版本覆盖当前工作区的文件！

将数据推送到远程仓库
git push [remote-name] [branch-name]
将本地的master分支推送到远程的origin服务器上
git push origin master

标签
1、轻量标签：很想一个不变的分支，它只是一个指向某次提交的指针。
git tag v1.0
2、注释标签：会作为完整的对象存储在Git数据库中。
git tag -a v1.0 -m "my version v1.0"
3、显示标签
git tag
git show v1.0
4、补加标签
git tag -a v1.1 9fceb02（某次提交）

4、将标签推送到远程服务器上
$ git push origin --tags

创建和删除分支
创建： git checkout -b newbranch   (创建并切换到newbranch分支)
删除： git checkout -d newbranch

合并分支
git checkout master
git merge hotfix       
当前在master分支上，将有更新内容的分支hotfix 合并到当前的master分支。 
合并分支时的冲突解决：
1、决定保留的最终内容。
2、删除掉<<<<<<   、======== 、>>>>>>>>>  这三行的内容。

远程分支(跟踪分支)
将本地分支推送到远程分支:  git push origin(远程库) serverfix(本地分支)
上述等价于：  git push origin serverfix(本地分支):serverfix(远程分支)
默认推送到远程库同名分支，也可推送到远程库不同名分支awesomebranch
git push origin serverfix:awesomebranch
如果获取服务器上数据时，获取到了本地还没有的新的远程跟踪分支，Git不会自动创建
新的分支(如serverfix2)，而只是拥有了指向origin/serverfix2的指针，要把该分支上的工作
合并到本地serverfix2上，可以执行命令：
git checkout -b serverfix2 origin/serverfix2   
上述创建的 本地serverfix2 分支 也叫 跟踪分支(上游分支)。
创建跟踪分支也可简写为：
git checkout --track origin/serverfix2
或 git checkout serverfix2   （切换分支操作时，如果该分支未创建，并且该分支名称和远程某个远程
分支名称一致，Git就会自动创建跟踪分支）
创建不同名跟踪分支： git checkout -b  otherserverifx2  origin/serverfix2
如果想给本地已存在的分支设置跟踪分支，或更改本地分支对应的远程分支，操作如下：
git branch -u origin/serverfix2   （将当前分支设置为远程serverfix 的跟踪分支） 或是
git branch --set-upstream-to=origin/serverfix2  local_branch
git branch --set-upstream-to=origin/remote_branch  your_branch
git branch -vv 查看设置了哪些跟踪分支。
删除远程分支
git push origin --delete serverfix

查看分支合并的记录
git log --graph

变基
Git中，要把更改从一个分支整合到另一个分支，有两种主要方式：合并(merge)和变基(rebase) 。即把某个
分支上的所有提及的更改在另一个分支上重现一遍。
git chekcout experiment
git rebase master
上述是将experiment分支上的提交整合到master上。注意上述操作对象和merge相反。
上述变基后，experiment 分支和master在一条线，但先于master分支，此时master滞后。现在可以
在master分支进行快进合并。
git checkout master
git merger experiment
变基方式可以获得更简洁的提交历史，通常项目中，应该在本地开发后，就要把自己的工作变基到origin/master上。

复杂变基
git rebase --onto master server client
上述命令是：将当前分支切换到client分支，并找出client分支和server分支的共同祖先提交，然后把自共同祖先以来
client分支上独有的工作在master分支上重现。 这里 master是目标。client变基到(onto) master。
直接变基操作
git reabse [basebranch] [topicbranch]
直接对该分支执行变基操作，而不需要先切换到该分支。该命令会读取主题分支(server)上的更改，并在基础分支(master)
上重现。
git rebase master(目标) server(需要合并的内容)

注意：变基完后应用merge进行合并操作。


Git  别名
git config --global alias.st status
git config --global alias.br branch
git config --global alias.ci commit
git config -global alias.co checkout
现在可以用 git st  代替 git status


子模块
1、添加子模块
git submodule add https://github.com/chaconinc/DbConnector
子模块会将子项目放入一个与仓库同名的目录中，如此处DbConnector 目录。该文件与别的文件一样，也受版本控制的
影响，会一起被推送和拉去。当不在该目录时，Git并不会跟踪其中的内容，而是把它看作仓库中的一次特殊的提交。
2、克隆子模块
git clone https://github.com/chaconinc/MainProject
默认会得到含有子模块的目录，但是目录中并没有文件。必须分别执行两条命令获取数据。
git submodule init
git submodule update
下述会自动初始化并更新每个子模块
git clone --recursive https://github.com/chaconinc/MainProject
要查看子模块中新的工作内容，可进入相应目录，执行git fetch  和 给i他merge。


git添加.gitignore后不生效问题
之所以将文件添加进了.gitignore文件但不生效，是因为该文件已经被add进git仓库了，已经被git托管了，这时git就没法ignore了。解决办法是先用git rm --cached将这些文件从git仓库中取消托管并提交，然后.gitignore文件才会生效。详细见如下描述。
已经添加到git仓库中的文件，如果在.gitignore中加入忽略，是不会生效的，因为他们已经添加到git仓库中了。要先git rm --cached在git仓库中删除这些文件，然后再用git commit 提交这个删除操作。然后，.gitignore中对这些文件的忽略才会生效。
注意：git rm --cached只是让git不再托管这些文件，一定要加上--cached选项，如果不加，git不仅删除此文件的托管关系，还会从硬盘上删除此文件，可怕~~

解决方法
1 从 Git 的数据库中删除对于该文件的追踪；
2 把对应的规则写入.gitignore，让忽略真正生效；
3 提交＋推送。
git rm -r --cached .
git add .
git commit 
针对某个文件：
git rm --cached bb/bb.c
git commit -m "ddd"


Git忽略规则(.gitignore配置）不生效原因和解决
第一种方法:
.gitignore中已经标明忽略的文件目录下的文件，git push的时候还会出现在push的目录中，或者用git status查看状态，想要忽略的文件还是显示被追踪状态。
原因是因为在git忽略目录中，新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，
这时候我们就应该先把本地缓存删除，然后再进行git的提交，这样就不会出现忽略的文件了。
解决方法:
git清除本地缓存（改变成未track状态），然后再提交:
[root@kevin ~]# git rm -r --cached .
[root@kevin ~]# git add .
[root@kevin ~]# git commit -m 'update .gitignore'
[root@kevin ~]# git push -u origin master
需要特别注意的是：
1）.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。
2）想要.gitignore起作用，必须要在这些文件不在暂存区中才可以，.gitignore文件只是忽略没有被staged(cached)文件，对于已经被staged文件，加入ignore文件时一定要先从staged移除，才可以忽略。 
第二种方法:（推荐）
在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。
[root@kevin ~]# git update-index --assume-unchanged PATH                  //在PATH处输入要忽略的文件
git update-index --assume-unchanged 

在使用.gitignore文件后如何删除远程仓库中以前上传的此类文件而保留本地文件
在使用git和github的时候，之前没有写.gitignore文件，就上传了一些没有必要的文件，在添加了.gitignore文件后，就想删除远程仓库中的文件却想保存本地的文件。
这时候不可以直接使用"git rm directory"，这样会删除本地仓库的文件。可以使用"git rm -r Ccached directory"来删除缓冲，然后进行"commit"和"push"，
这样会发现远程仓库中的不必要文件就被删除了，以后可以直接使用"git add -A"来添加修改的内容，上传的文件就会受到.gitignore文件的内容约束。

设置不检查的文件
在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。
[root@kevin ~]# git update-index --assume-unchanged PATH 

git pull 失败 ,提示：fatal: refusing to merge unrelated histories
这是因为远程仓库origin上的分支master和本地分支master被Git认为是不同的仓库，所以不能直接合并。
参考http://stackoverflow.com/questions/37937984/git-refusing-to-merge-unrelated-histories。

解决方案：添加--allow-unrelated-histories
假如我们的远程仓库是origin，分支是master，那么我们 需要这样写git pull origin master ----allow-unrelated-histories
push和pull命令格式：
git push <远程主机名> <本地分支名>[:<远程分支名>]    
git push oschina master， 省略远程分支名，代表推送到有追踪关系的远程分支（一般为同名）
git pull <远程主机名> <远程分支>:<本地分支>       
git push origin A:B 就是把 Apush 到 B 上

合并分支
合并分支有三种方式
1、Merge branches （合并分支）
2、Rebase branches （重新设置分支）
3、Cherry-pick  （将一个分支的单独提交应用于另一个分支）

git查看本地分支关联（跟踪）的远程分支之间的对应关系，本地分支对应哪个远程分支
git branch -vv


gitlab-ctl start # 启动所有 gitlab 组件；
gitlab-ctl stop # 停止所有 gitlab 组件；
gitlab-ctl restart # 重启所有 gitlab 组件；
gitlab-ctl status # 查看服务状态；
gitlab-ctl reconfigure # 启动服务；
vim /etc/gitlab/gitlab.rb # 修改默认的配置文件；
gitlab-rake gitlab:check SANITIZE=true --trace # 检查gitlab；
gitlab-ctl tail # 查看日志；


GitLab 服务器
https://www.cnblogs.com/easonscx/p/11969403.html
http://www.weijingbiji.com/1122/
1、安装Gitlab必要的依赖项，还将在系统防火墙中打开HTTP和SSH访问
安装命令：yum install -y curl policycoreutils-python openssh-server
激活命令：systemctl enable sshd
启用命令：systemctl start sshd
防火墙命令：firewall-cmd --permanent--add-service=http && systemctl reload firewalld    //如果系统已关闭防火墙选项，忽略此步骤。

2、安装Postfix以发送通知电子邮件
安装命令：yum install postfix
激活命令：systemctl enable postfix
启用命令：systemctl start postfix

3、下载GitLab软件包（社区版），地址：https://packages.gitlab.com/gitlab/gitlab-ce

4、查看Gitlab相关目录，命令：find / -name gitlab
Gitlab目录结构
/opt/gitlab/ 　　      # 主目录
/etc/gitlab/ 　　      # 放置配置文件
/var/opt/gitlab/ 　　# 各个组件
/var/log/gitlab/ 　　# 放置日志文件
/var/opt/gitlab/git-data/repositories 　　 #数据库的地址　　
/var/opt/gitlab/postgresql/data 　　       #gitlab组和项目的地址
/etc/gitlab/gitlab.rb                              #gitlab配置文件

5、初始化Gitlab命令（保存配置或重新载入配置）：gitlab-ctl reconfigure

6、Gitlab服务的启停管理
启动服务： gitlab-ctl start
停止服务： gitlab-ctl stop
重启服务： gitlab-ctl restart
查看状态： gitlab-ctl status

7、Gitlab的supervisor方式启动服务
服务启动命令：   systemctl start gitlab-runsvdir.service
服务停止命令：   systemctl stop gitlab-runsvdir.service
服务重启命令：   systemctl restart gitlab-runsvdir.service
服务开机启动命令：   systemctl enable gitlab-runsvdir.service
取消开机启动命令：   systemctl disable gitlab-runsvdir.service
服务查看命令：   systemctl list-unit-files

8、Gitlab服务日志查看：/usr/bin/gitlab-ctl tail         //可以查看到gitlab所有插件的日志情况
 

Gitlab服务组成
nginx: 静态web服务器
gitlab-shell: 用于处理Git命令和修改authorized keys列表
gitlab-workhorse: 轻量级的反向代理服务器
logrotate：日志文件管理工具
postgresql：数据库
redis：缓存数据库
sidekiq：用于在后台执行队列任务（异步执行）
unicorn：An HTTP server for Rack applications，GitLab Rails应用是托管在这个服务器上面的。

运维故障排查
# 查看版本 
cat /opt/gitlab/embedded/service/gitlab-rails/VERSION
# 检查gitlab 
gitlab-rake gitlab:check SANITIZE=true --trace
# 实时查看日志 
gitlab-ctl tail
# 数据库关系升级 
gitlab-rake db:migrate
# 清理redis缓存 
gitlab-rake cache:clear
# 升级GitLab-ce 版本 
yum update gitlab-ce 
# 升级PostgreSQL最新版本 
gitlab-ctl pg-upgrade

服务管理
# 启动所有 gitlab 组件： 
gitlab-ctl start
# 停止所有 gitlab 组件： 
gitlab-ctl stop 
# 停止所有 gitlab postgresql 组件： 
gitlab-ctl stop postgresql 
# 停止相关数据连接服务 
gitlab-ctl stop unicorn gitlab-ctl stop sidekiq 
# 重启所有 gitlab 组件： 
gitlab-ctl restart 
# 重启所有 gitlab gitlab-workhorse 组件： 
gitlab-ctl restart  gitlab-workhorse 
# 查看服务状态 
gitlab-ctl status 
# 生成配置并启动服务 
gitlab-ctl reconfigure

日志管理
# 实时查看所有日志 
gitlab-ctl tail
# 实时检查redis的日志 
gitlab-ctl tail redis  
# 实时检查postgresql的日志 
gitlab-ctl tail postgresql   
# 检查gitlab-workhorse的日志 
gitlab-ctl tail gitlab-workhorse  
# 检查logrotate的日志 
gitlab-ctl tail logrotate   
# 检查nginx的日志 
gitlab-ctl tail nginx   
# 检查sidekiq的日志 
gitlab-ctl tail sidekiq  
# 检查unicorn的日志 
gitlab-ctl tail unicorn
#检查在gitlab中是否有任何配置。在指定版本中删除的rb。
gitlab-ctl check-config 
#安装部署页面
gitlab-ctl deploy-page
#将用户配置与包可用配置进行比较
gitlab-ctl diff-config
#删除所有用户和组	
gitlab-ctl remove-accounts	
#版本升级
gitlab-ctl upgrade

GitLab备份和恢复
GitLab备份的默认目录是 /var/opt/gitlab/backups ，可通过修改/etc/gitlab/gitlab.rb更改。
gitlab_rails['backup_path'] = '/data/backups'
备份命令:  gitlab-rake gitlab:backup:create
备注：该命令会在备份目录（默认：/var/opt/gitlab/backups/）下创建一个tar压缩包xxxxxxxx_gitlab_backup.tar，
其中开头的xxxxxx是备份创建的时间戳，这个压缩包包括GitLab整个的完整部分。
修改配置保留七天备份 /etc/gitlab/gitlab.rb 
# 数值单位：秒  gitlab_rails['backup_keep_time'] = 604800

恢复备份文件：
停止 unicorn 和 sidekiq ，保证数据库没有新的连接，不会有写数据情况。
# 停止相关数据连接服务
gitlab-ctl stop unicorn
gitlab-ctl stop sidekiq
# 指定恢复文件，会自动去备份目录找。如/var/opt/gitlab/backups/499244722_2020_04_05_12.10.1_gitlab_backup.tar。
# 指定文件名的格式类似：499242399_2020_04_05_12.10.1，加 “_gitlab_backup.tar”
# 一定按这样的格式指定，否则会出现 The backup file does not exist! 的错误
gitlab-rake gitlab:backup:restore BACKUP=499242399_2020_04_05_12.10.1
# 启动Gitlab
gitlab-ctl start

gitlab拉取代码每次都需要输入用户名和密码
解决方案： git config Cglobal credential.helper store

git push每次都需要输入帐号密码的解决方法
解决办法    在git bash中输入：
git config --global credential.helper store
执行完上面的git命令后，在命令行正常执行pull ，push，如果是在以上操作完之后第一次执行pull push，需要输入一次用户名密码，以后不再需要输入。
第一次向新的URL输入用户名密码之后会发现 .git-credentials中追加了类似 https://username:password@hello.com的内容。
vim查看home路径中的.gitconfig，会在之前
[user]
name =**********
email=***********
的基础上多出
[credential]
helper = store

nginx配置文件路径
/var/opt/gitlab/nginx/conf

git clone 输入错误用户名密码后显示
remote: Incorrect username or password ( access token )
fatal: Authentication failed 
没办法重新输入，要重新输入用户名密码的话，需要清除错误的用户名密码：
git config --system --unset credential.helper

























